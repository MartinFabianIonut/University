#include <mpi.h>
#include <iostream>
#include <fstream>
#include <chrono>
#include <string>

using namespace std;

const int n = 1000;
const int m = 1000;
const int k = 3;

int myid, numprocs;
MPI_Status status;

ifstream fin("C:\\GIT\\University\\Year 3\\Parallel and Distributed Programming\\Laboratory 3\\First\\First\\input.txt");
ifstream finConvolution("C:\\GIT\\University\\Year 3\\Parallel and Distributed Programming\\Laboratory 3\\First\\First\\convolution.txt");
ofstream fout("C:\\GIT\\University\\Year 3\\Parallel and Distributed Programming\\Laboratory 3\\First\\First\\output.txt");

int convolutionMatrix[k][k];

int** allocateMatrix(int n, int m)
{
	int** matrix = new int* [n];
	for (int i = 0; i < n; ++i)
		matrix[i] = new int[m];
	return matrix;
}

void deallocateMatrix(int** matrix, int n)
{
	for (int i = 0; i < n; ++i)
		delete[] matrix[i];
	delete[] matrix;
}

void writeMatrix(int** inputMatrix, int start, int end)
{
	for (int i = start; i < end; i++)
	{
		for (int j = 0; j < m; j++)
		{
			fout << inputMatrix[i][j] << " ";
		}
		fout << endl;
	}
}

void readLinesFromStartToEnd(int** inputMatrix, int start, int end)
{
	for (int i = start; i < end; i++)
	{
		for (int j = 0; j < n; j++)
		{
			fin >> inputMatrix[i][j];
		}
	}
}

int resultAtConvolute(int** inputMatrix, int i, int j)
{
	int result = 0;
	for (int p = 0; p < k; ++p)
	{
		for (int q = 0; q < k; ++q)
		{
			int x = min(max(i - k / 2 + p, 1), n - 1);
			int y = min(max(j - k / 2 + q, 0), m - 1);
			result += inputMatrix[x][y] * convolutionMatrix[p][q];
		}
	}
	return result;
}

void applyConvolution(int** localInputMatrix, int start, int end)
{
	if (myid == 1)
	{
		MPI_Send(localInputMatrix[end], m, MPI_INT, myid + 1, 0, MPI_COMM_WORLD);
		MPI_Recv(localInputMatrix[end + 1], m, MPI_INT, myid + 1, 0, MPI_COMM_WORLD, &status);
	}
	if (myid > 1 && myid < numprocs - 1)
	{
		MPI_Recv(localInputMatrix[start - 1], m, MPI_INT, myid - 1, 0, MPI_COMM_WORLD, &status);
		MPI_Send(localInputMatrix[start], m, MPI_INT, myid - 1, 0, MPI_COMM_WORLD);
		MPI_Send(localInputMatrix[end], m, MPI_INT, myid + 1, 0, MPI_COMM_WORLD);
		MPI_Recv(localInputMatrix[end + 1], m, MPI_INT, myid + 1, 0, MPI_COMM_WORLD, &status);
	}
	if (myid == numprocs - 1)
	{
		MPI_Recv(localInputMatrix[start - 1], m, MPI_INT, myid - 1, 0, MPI_COMM_WORLD, &status);
		MPI_Send(localInputMatrix[start], m, MPI_INT, myid - 1, 0, MPI_COMM_WORLD);
	}

	int** buffer = allocateMatrix(end - start + 2, m);

	for (int i = start; i <= end; ++i)
	{
		for (int j = 0; j < m; ++j)
		{
			buffer[i - start][j] = resultAtConvolute(localInputMatrix, i, j);
		}
	}


	for (int i = start; i <= end; ++i)
	{
		for (int j = 0; j < m; ++j)
		{
			localInputMatrix[i][j] = buffer[i - start][j];
		}
	}

	deallocateMatrix(buffer, end - start + 2);
}

int main(int argc, char* argv[])
{
	MPI_Init(NULL, NULL);
	MPI_Comm_rank(MPI_COMM_WORLD, &myid);
	MPI_Comm_size(MPI_COMM_WORLD, &numprocs);
	int start = 0, end;
	if (myid == 0)
	{
		int** inputMatrix = allocateMatrix(n, m);
		auto startTime = chrono::high_resolution_clock::now();
		for (int i = 0; i < k; i++)
		{
			for (int j = 0; j < k; j++)
			{
				finConvolution >> convolutionMatrix[i][j];
			}
		}
		finConvolution.close();
		MPI_Bcast(convolutionMatrix, k * k, MPI_INT, 0, MPI_COMM_WORLD);
		int cat, rest;
		cat = n / (numprocs - 1);
		rest = n % (numprocs - 1);
		for (int i = 1; i < numprocs; i++)
		{
			end = start + cat;
			if (rest > 0)
			{
				end++;
				rest--;
			}
			readLinesFromStartToEnd(inputMatrix, start, end);
			MPI_Send(&start, 1, MPI_INT, i, 0, MPI_COMM_WORLD);
			MPI_Send(&end, 1, MPI_INT, i, 0, MPI_COMM_WORLD);
			MPI_Send(inputMatrix[start], (end - start) * m, MPI_INT, i, 0, MPI_COMM_WORLD);
			start = end + 1;
		}
		fin.close();
		for (int i = 1; i < numprocs; i++)
		{
			MPI_Recv(&start, 1, MPI_INT, i, 0, MPI_COMM_WORLD, &status);
			MPI_Recv(&end, 1, MPI_INT, i, 0, MPI_COMM_WORLD, &status);
			MPI_Recv(inputMatrix[start], (end - start) * m, MPI_INT, i, 0, MPI_COMM_WORLD, &status);
			writeMatrix(inputMatrix, start, end);
		}
		fout.close();

		auto endTime = chrono::high_resolution_clock::now();

		auto duration = chrono::duration<double, milli>(endTime - startTime).count();
		string durationString = to_string(duration);
		cout << durationString;
		deallocateMatrix(inputMatrix, n);
	}
	else
	{
		MPI_Bcast(convolutionMatrix, k * k, MPI_INT, 0, MPI_COMM_WORLD);

		MPI_Recv(&start, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
		MPI_Recv(&end, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);

		int localRows = end - start + 2;
		int** localInputMatrix = allocateMatrix(localRows, m);

		MPI_Recv(localInputMatrix[1], (end - start) * m, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
		
		applyConvolution(localInputMatrix, 1, localRows - 2);
		cout << "Process " << myid << " finished 1" << endl;

		MPI_Send(&start, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
		MPI_Send(&end, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
		MPI_Send(localInputMatrix[1], (end - start) * m, MPI_INT, 0, 0, MPI_COMM_WORLD);
		cout << "Process " << myid << " finished" << endl;

		deallocateMatrix(localInputMatrix, localRows);
	}
	MPI_Finalize();
}
